#include<queue>
#include<iostream>
#include<cmath>
using namespace std;
#define ll long long
#define rep(i,n) for(ll i = 0; i < n; i++)
#define rep2(i,start,end) for(ll i = start; i < end; i++)
#define dwn(i,n) for(int i = n; i >= 0; i--)
#define dwn2(i,start,end) for(ll i = start; i >= end; i--)
#define pll pair<ll,ll>
#define mk(x,y) make_pair(x,y)
#define pdl pair<double, ll>
const ll N = 6e5 + 300;
const ll INF = 0x3f3f3f;
const ll mod = 1e9 + 7;
typedef struct{
	int to,val,next;
}nod;
nod edge[2*N];
int head[N];
int d[N];	//表示深度depth 
int tot,root;
int f[N][22],lg[N];		//f数组表示倍增的父节点，lg为跳跃最大距离 
void init(int n){
	rep2(i,0,n+2){
		head[i] = 0;
		d[i] = 0;
	}
	tot = 0;
}

void add(int x, int y){
	edge[++tot].next = head[x];
	edge[tot].to = y;
	head[x] = tot;
}

void dfs(int x, int fath){
	d[x] = d[fath] + 1;
	f[x][0] = fath;
	for(int i = 1; (1<<i) <= d[x]; i++){
		f[x][i] = f[f[x][i-1]][i-1];
	}
	for(int i = head[x]; i; i = edge[i].next){
		if(edge[i].to != fath){
			dfs(edge[i].to, x);
		}
	}
}

int LCA(int x, int y){
	if(d[x] < d[y]) swap(x,y);
	while(d[x] > d[y]){
		x = f[x][lg[d[x] - d[y]] - 1];
	}
	if(x == y) return x;
	for(int i = lg[d[x]] - 1; i >= 0; i--){
		if(f[x][i] != f[y][i]){
			x = f[x][i];
			y = f[y][i];
		}
	}
	return f[x][0];
}

int main(){
		int n,m;
		cin>>n>>m>>root;
		init(n);
		rep(i,n-1){
			int x,y;
			cin>>x>>y;
			add(x,y);
			add(y,x);
		}
		dfs(root, 0);
		for(int i = 1; i <= n; i++){		//常数优化 
			lg[i] = lg[i-1] + (1<<lg[i-1] == i);
		}
//		rep2(i,1,n+1){
//			cout<<d[i]<<" ";
//		}
//		cout<<endl;
		rep(i,m){
			int x,y;
			scanf("%d%d",&x,&y);
			printf("%d\n", LCA(x,y));
		}
	return 0;
}




